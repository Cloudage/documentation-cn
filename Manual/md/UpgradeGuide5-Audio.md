##Unity 5.0 中的音频

如果项目使用了音频功能，在将项目从 Unity 4 升级到 Unity 5 时需要注意以下注意事项。

###音频剪辑 (AudioClip)

音频剪辑方面存在大量更改。首先，资源上不再有 3D 标志。此标志已经以 Spatial Blend 滑动条的形式移动到音频源 (AudioSource) 中，允许在运行时将声音从 2D 变为 3D。旧项目将以这样的方式导入：场景游戏对象上已分配剪辑的音频源将根据音频剪辑的旧 3D 标志设置其 Spatial Blend 参数。由于显而易见的原因，这对于动态分配剪辑到音频源的脚本是不可能的，因此这需要手动修复。

旧 3D 属性的默认设置为 true，但在新系统中，默认情况下，Spatial Blend 参数的默认设置为 2D。

最后，现在可对音频剪辑进行多重编辑。

###格式

Format 属性的命名已更改，现在命名中将反映存储数据的方法，而不是因平台而异的特定文件格式。所以从现在开始，Uncompressed 表示原始样本数据，Compressed 表示最适合平台的有损压缩方法，ADPCM 表示一种轻量级（就 CPU 而言）压缩方法，最适合包含大量噪音（脚步声、撞击声、武器声音等）并需要大量播放的自然音频信号。

###在后台预加载和加载音频数据

音频剪辑有一个新功能，允许通过一个选项决定是否预加载音频数据。音频剪辑的任何属性都与实际音频数据加载状态分离，并可以随时查询，因此现在的按需加载功能有助于减少音频剪辑的内存使用量。此外，音频剪辑可以在后台加载他们的音频数据，而不会阻止主游戏线程以及导致丢帧。当然也可以通过脚本 API 来控制加载过程。

###多重编辑
所有音频剪辑现在都支持多重编辑。

###Force to Mono
Force To Mono 选项现在可以对生成的向下混音执行峰值归一化。

###GetData/SetData

只有将未压缩的音频数据存储为 PCM 或在加载时执行解压缩的剪辑才支持这些 API 调用。以前有更多剪辑支持这些调用，但模式不是很清晰，因为这既依赖于目标平台又在 Editor 和独立平台播放器中具有不同的行为。作为一个新事物，跟踪器文件也可以作为 PCM 数据解压缩到内存中，因此也可以对这些文件使用 GetData/SetData。

###音频源暂停行为

现在，Unity5 中的暂停行为在 Play 调用和 PlayOneShots 调用之间保持一致。暂停音频源会暂停通过这两种方式播放的语音，而调用 Play 或 PlayOneShot 也会取消暂停 (unpause) 通过这两种方式播放的音频源。

为了方便在不播放指定剪辑的情况下取消暂停音频源（对于播放一次性语音很有用），我们添加了一个新函数 AudioSource.Unpause ()。

###混音器

混音器 (AudioMixer) 是 Unity 5 的一项新功能，允许将音频源的音频数据以复杂路由方式传送到可以应用效果的混音组。与音频滤波器 (Audio Filter) 组件的一个关键区别在于音频滤波器根据每个音频源进行实例化，因此如果游戏有大量音频源包含滤波器，或者脚本仅用于创建游戏对象的多个实例，则该组件在 CPU 方面的成本会更高。使用混音器后，现在可以设置具有相同效果的组，并只需通过共享效果从音频源路由音频，因此降低了 CPU 使用率。

混音器目前不支持基于脚本的效果，但却有一个新的原生音频插件 API，让开发人员能够编写与其他内置效果无缝集成的高性能效果。

###AudioSettings

音频系统的配置方式已更改。仍然应该在音频项目设置中配置用于设置扬声器模式和 DSP 缓冲区大小（即延迟）的总体设置，除此之外，现在还可以配置实际和虚拟语音计数。真实的语音计数指定了可以同时听到语音数，因此对游戏的整体 CPU 消耗有很大影响。以前，此数值以硬编码方式设置为 32，但有一些特定于平台的例外情况。当播放的语音数量超过此数量时，声音最小的语音将被暂停，直到这些语音成为主导语音或某些主导语音停止播放为止。这些语音在播放时将被跳过。它们不会停止，只是在没有带宽之前就会处于非活动状态。虚拟语音计数定义了总共可以管理的语音数，因此如果播放的语音数量超过此数量，则将停止声音最小的语音。

仍然可以从 AudioSettings.outputSampleRate 和 AudioSettings.speakerMode 进行读取，但现在已弃用 setter，SetDSPBufferSize 函数也已弃用。为了在运行时进行所需的音频配置更改，现在的替代方法是使用一个称为 AudioConfiguration 的结构。为获得此结构，可执行 AudioSettings.GetConfiguration()，该调用将返回音频输出设备上的有效设置。可以对此结构进行更改并通过 AudioSettings.Reset() 进行应用；此调用将返回布尔结果，具体取决于应用更改的结果是成功还是失败。

每当音频配置发生更改时，无论是由脚本通过 AudioSettings.Reset() 进行的还是由外部事件导致的（如插入带有音频支持的 HDMI 监视器、外部声卡或 USB 耳机），都会调用一个用户定义的回调 AudioSettings.OnAudioConfigurationChanged(bool deviceChanged)。如果更改是由 AudioSettings.Reset() 调用引起的，则参数 deviceChanged 将为 false；如果由外部设备更改引起（这也可能会更改正在使用的音频设备的采样率），则为 true。借助该回调，可以重新创建任何易失性声音（例如生成的 PCM 剪辑）、恢复音频状态或通过调用 AudioSettings.Reset() 来进一步调整音频设置。
